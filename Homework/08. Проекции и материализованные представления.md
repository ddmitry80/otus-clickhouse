# 1. Создание таблицы

Создайте таблицу sales с полями:
- id (UInt32) — уникальный идентификатор продажи
- product_id (UInt32) — идентификатор продукта
- quantity (UInt32) — количество проданных единиц
- price (Float32) — цена за единицу
- sale_date (DateTime) — дата продажи

Заполните таблицу тестовыми данными.

```sql
CREATE TABLE task8 (
    id UInt32  -- уникальный идентификатор продажи
    , product_id UInt32  -- идентификатор продукта
    , quantity UInt32  -- количество проданнных едениц
    , price Float32  -- цена за еденицу
    , sale_date DateTime  -- дата продажи
) ENGINE = MergeTree ORDER BY (id);

INSERT INTO task8 (id, product_id, quantity, price, sale_date) VALUES
(1, 50, 7, 13.64, '2023-09-19 00:00:00'),
(2, 63, 7, 92.64, '2023-06-05 00:00:00'),
(3, 62, 6, 62.50, '2023-04-22 00:00:00'),
(4, 65, 3, 35.37, '2023-02-18 00:00:00'),
(5, 80, 5, 98.85, '2023-09-30 00:00:00'),
(6, 91, 10, 91.19, '2023-06-08 00:00:00'),
(7, 13, 2, 90.90, '2023-12-17 00:00:00'),
(8, 43, 8, 60.38, '2023-07-01 00:00:00'),
(9, 56, 6, 64.98, '2023-04-15 00:00:00'),
(10, 71, 8, 49.84, '2023-09-24 00:00:00'),
(11, 34, 1, 82.45, '2023-10-08 00:00:00'),
(12, 2, 2, 74.77, '2023-07-24 00:00:00'),
(13, 91, 1, 65.07, '2023-06-20 00:00:00'),
(14, 32, 6, 73.33, '2023-02-02 00:00:00'),
(15, 25, 10, 29.95, '2023-03-14 00:00:00'),
(16, 70, 8, 18.21, '2023-06-13 00:00:00'),
(17, 66, 8, 19.82, '2023-10-10 00:00:00'),
(18, 38, 2, 59.27, '2023-10-04 00:00:00'),
(19, 27, 10, 59.25, '2023-05-28 00:00:00'),
(20, 57, 2, 63.67, '2023-07-17 00:00:00');
```

# 2. Создание проекции:

Создайте проекцию для таблицы sales, которая будет агрегировать данные по product_id и считать общую сумму продаж (количество и сумма по цене) за каждый продукт.

```sql
ALTER TABLE task8 DROP PROJECTION IF EXISTS product_agg;
ALTER TABLE task8 ADD PROJECTION product_agg (
    SELECT product_id, sum(quantity*price)
    GROUP BY product_id
);
-- материализуем проекцию
ALTER TABLE task8 MATERIALIZE PROJECTION product_agg;
```

# 3. Создание материализованного представления:

Создайте материализованное представление sales_mv, которое будет автоматически обновляться при вставке новых данных в таблицу sales. Оно должно хранить общие продажи по продуктам с полями:
- product_id
- total_quantity
- total_sales

```sql
-- Создадим таблицу для хранения результатов работы мат. вью
CREATE TABLE task8_totals (
    product_id UInt32
    , total_quantity AggregateFunction(sum, UInt32)
    , total_sales AggregateFunction(sum, Float64)
) ENGINE=AggregatingMergeTree() ORDER BY (product_id);

-- Само мат. вью
CREATE MATERIALIZED VIEW task8_mv TO task8_totals
POPULATE
AS SELECT
    product_id
    , sumState(quantity) AS total_quantity
    , sumState(quantity*price) AS total_sales
FROM task8
GROUP BY product_id;
```

# 4. Запросы к данным:

## Напишите запрос, который извлекает данные из проекции sales_projection.
```sql
SELECT product_id, sum(quantity*price)
FROM task8
GROUP BY product_id 
```

## Напишите запрос, который извлекает данные из материализованного представления sales_mv.
```sql
SELECT
    product_id
    , sumMerge(total_quantity) AS total_quantity
    , sumMerge(total_sales) AS total_sales
FROM task8_totals
GROUP BY product_id 
ORDER BY product_id ;
```

# 5. Сравнение производительности:

Сравните время выполнения запроса к основной таблице sales с запросом к проекции sales_projection и материализованному представлению sales_mv. Обратите внимание на разницу в производительности.

Для начала, нужно обеспечить наличие данных в матвью. Я не нашел способа залить уже имеющиеся в исходной таблице данные в матвью. Ключевое слово `POPULATE` не работает в случае EXPLICIT, получаю ошибку:
```
SQL Error [62] [07000]: Code: 62. DB::Exception: When creating a materialized view you can't declare both 'TO [db].[table]' and 'POPULATE'. (SYNTAX_ERROR) (version 25.1.5.31 (official build))
```

Придется перезалить данные
```sql
TRUNCATE TABLE task8;
INSERT INTO task8 (id, product_id, quantity, price, sale_date) VALUES
(1, 50, 7, 13.64, '2023-09-19 00:00:00'),
(2, 63, 7, 92.64, '2023-06-05 00:00:00'),
(3, 62, 6, 62.50, '2023-04-22 00:00:00'),
(4, 65, 3, 35.37, '2023-02-18 00:00:00'),
(5, 80, 5, 98.85, '2023-09-30 00:00:00'),
(6, 91, 10, 91.19, '2023-06-08 00:00:00'),
(7, 13, 2, 90.90, '2023-12-17 00:00:00'),
(8, 43, 8, 60.38, '2023-07-01 00:00:00'),
(9, 56, 6, 64.98, '2023-04-15 00:00:00'),
(10, 71, 8, 49.84, '2023-09-24 00:00:00'),
(11, 34, 1, 82.45, '2023-10-08 00:00:00'),
(12, 2, 2, 74.77, '2023-07-24 00:00:00'),
(13, 91, 1, 65.07, '2023-06-20 00:00:00'),
(14, 32, 6, 73.33, '2023-02-02 00:00:00'),
(15, 25, 10, 29.95, '2023-03-14 00:00:00'),
(16, 70, 8, 18.21, '2023-06-13 00:00:00'),
(17, 66, 8, 19.82, '2023-10-10 00:00:00'),
(18, 38, 2, 59.27, '2023-10-04 00:00:00'),
(19, 27, 10, 59.25, '2023-05-28 00:00:00'),
(20, 57, 2, 63.67, '2023-07-17 00:00:00');
```

Измеряем производительность. Сначала прочитаем из проекции
```sql
SELECT product_id, sum(quantity*price) 
FROM task8
GROUP BY product_id 
FORMAT Null
```
0 rows in set. Elapsed: 0.004 sec.

Теперь обратимся к матвью
```sql
SELECT
    product_id
    , sumMerge(total_sales) AS total_sales
FROM task8_totals
GROUP BY product_id 
FORMAT Null
```

0 rows in set. Elapsed: 0.004 sec.

На данном размере датасета разница не заметна. Подозреваю, нужны на порядки большие размеры, чтобы разница стала ощутимой.
Предположу, что существенной разницы в данном случае, при запросе к представлению и матвью, и не должно быть, т.к. даные и там, и там уже предагрегированные.

